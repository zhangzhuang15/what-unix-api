### 如何计算内存对齐
计算方式建立在3个概念上：
* 自身对齐值
* 有效对齐值
* 要求对齐值

自身对齐值：

* C语言的基本数据类型，自身对齐值就是自身大小；
  * 比如 int 是 4 字节，那么 int 类型数据的自身对齐值就是 4；
* C语言的结构体数据类型，自身对齐值是其内部field自身对齐值的最大值；
  ```c 
  struct man {
    char sex;
    int age;
  }

  // char 自身对齐值是 1；
  // int 自身对齐值是 4；
  // 所以，man 自身对齐值取最大的那个值 4；
  ```

要求对齐值：
C语言中，提供了一些宏，定义结构体需要按照多少字节对齐，这个就是 要求对齐值；

有效对齐值，就是自身对齐值和要求对齐值较小的那个值；

#### example
```c   

struct Man {
    char name;
    int  age;
    char sex;
}


// 计算下 Man 在内存对齐之后，占据多少内存。
// name 自身对齐值，有效对齐值都是 1；
// age 自身对齐值，有效对齐值都是 4；
// sex 自身对齐值，有效对齐值都是 1；
// Man 自身对齐值是 max(1, 4, 1) = 4;
// 没有指定对齐值，Man 的有效对齐值就是 4；
// 假设我们把 Man 的第一个字节放在地址为 0 的位置，
// name的存储的起始位置必须被1整除，可以放在0；
// age的有效对齐值是4，则它存储的起始地址必须被 4 整除，只能存储在地址为4的位置；
// sex和name一样，存储的位置是地址 8；
// Man 总共占据 9 字节；
```
<br>

```c   
struct Person {
    char name;
    char sex;
    int age;
}

// 计算 Person 内存占据多少。
// name 有效对齐值 1， 存储的地址必须能被 1 整除，放在位置 0；
// 同理， sex 放在位置 1；
// age 有效对齐值 4， 存储的地址必须能被 4 整除，放在位置 4；
// Person 占据 8 字节；
```
<br>

```c  
struct Man {
    char name;
    int  age;
    char sex;
}

struct H {
    char name;
    Man man;
    int id;
}

// 计算 H 占据多少内存。
// name 自身对齐值、有效对齐值都是 1；
// Man 自身对齐值是 4，因为没有要求对齐值，所以有效对齐值也是 4；
// id 自身对齐值、有效对齐值都是 4；
// name 放在 位置 0；
// man 必须放在能被 4 整除的位置，放在位置 4，man因为占据 9 字节，最后一个字节放在 位置 12；
// id 必须放在能被 4 整除的位置，跳过位置13，放在位置16；
// 算下来，H 占据 20 字节；

```

#### 内存对齐给Rust带来的问题
```c  
// Rust的 struct 默认不会按照 C 规则处理，
// Rust编译器会做出优化

struct Man {
    char name;
    int  age;
    char sex;
}

// 在 Rust 中会将 Man 做出编译优化，
// 将其调整为：

struct Man {
    char name;
    char sex;
    int  age;
}

// 在 Rust 中，就会出现实际 sex 地址比 age地址
// 要低，在Rust中操作地址时一定要小心；

// 实际上，使用Rust操作地址时，基本上会加入
// #[repr(C)]的宏，不做优化，按照C风格处理，
// 此时就可以放心按照C语言的方式去处理了。
```
