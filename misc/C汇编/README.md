##  C 和 汇编
* c语言和汇编关系紧密，对于底层的开发，常常需要在c语言中内联汇编代码。  
* c语言对于内联汇编代码的支持要比其他语言优秀，没什么开销。  
* c语言中的函数名、全局变量名，在汇编语言中就是label，反过来用汇编语言写的子过程label、数据label，在C语言中可以作为函数、全局变量使用。
  > 也就是说，C语言可以调用汇编语言编写的函数，汇编语言也可以调用C语言写的函数。从一定角度上看，汇编语言是机器语言的简记符号，C语言是汇编语言的简记符号。

<br>

## C 内联汇编方法
```C 

__asm__("mov x4, #23"
         :
         :
         :);

__asm("mov x4, #23"
      :
      :
      :);

asm("mov x4, #23"
    :
    :
    :);
```
> 推荐使用 `__asm__` 的方式。防止内联汇编代码被编译器优化，可使用 `__asm__ __volatile__`;  

[GNU内联汇编](https://www.cnblogs.com/ellabrain/p/15553035.html)

[AT&T汇编](http://www.javashuo.com/article/p-rwptqgme-mh.html)

<br>

## 外联汇编  
外联汇编是指c语言使用`.S`汇编文件中定义的函数。
为达到目的，C语言应该：
* 对要调用的函数用extern声明；
* 编译的时候要连同`.S`汇编代码一起编译；

<br>

## 汇编风格
汇编代码按照指令集分为 intel 和 arm 两个版本。  
* 两套体系的寄存器不同，汇编代码中的寄存器表达符不同；
* 两套体系的指令不同，汇编代码书写不同；
  
汇编代码按照书写风格分为 intel汇编 和 AT&T汇编。
* windows上常用 intel 汇编；
* unix系统上常用 AT&T 汇编；  
  
Intel体系的汇编中
* AT&T汇编的寄存器名称带有%号
* AT&T汇编和Intel汇编指令的源操作数、目的操作数顺序相反

**参考：**  
[arm寄存器体系结构](https://blog.csdn.net/u010681589/article/details/122400638)  
[arm寄存器简单介绍](https://www.jianshu.com/p/b29bb8f2e727)

<br>

## ABI约定
C语言中使用内联汇编实现一个函数的调用，必须要遵从ABI。  
Intel有Intel的ABI，Arm有Arm的ABI。

* Intel下函数参数存入栈中，返回值存入确定的寄存器中；
* Arm中函数参数优先存入寄存器中，寄存器不够用了，存入栈中，返回值将存入寄存器中；


## C 的入口点
* C 的入口点不是 main 函数；
* C 的入口点定义于 libc 中，以linux为例，入口点定义在glibc中，是一个叫做_start的汇编子过程标签，这个子过程会初始化栈、bss、数据区后，跳转到 main标签执行代码。我们编写的main函数在编译后变成汇编的main标签，所以_start子过程中可以识别到它，完成跳转。当main执行完毕后，会回到_start中，完成后续的一些数据清理，资源释放工作。
* 想_start这样的入口点，可以使用`ld链接器`和`链接器脚本`修改。