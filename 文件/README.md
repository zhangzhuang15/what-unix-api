## 文件权限管理
有些文件你可以打开，有些文件你无法打开，原因在于文件有一套权限管理机制。  

最直观感受文件权限管理的方式是执行 `ls -lh`
![ls结果图](./ls%E7%BB%93%E6%9E%9C.png)

`-rw-r--r--`描述的就是文件权限  

开头的`-`表示文件类型是**普通文件**，如果开头是`d`表示文件类型是**文件夹**。

`rw-r--r--`三位一组，分成三组，从左到右依次代表：
user - 文件拥有者的权限；
group - 文件所属组的权限；
other - 其他情况下文件的权限；

`rw-` 表示：
`r` - 文件拥有者有读权限；
`w` - 文件拥有者有写权限；
`-` - 文件拥有者没有执行该文件的权限；

请留意第三位：
如果是`x`，则拥有者具有执行该文件的权限；
如果是`s`，表示在执行该文件的时候，可以将进程的有效用户ID设置为文件拥有者ID，允许实际用户执行该文件；
> `rwx` 在 chmod 函数中，等于 4 + 2 + 1 = 7;
> `r` 对应 `<fcntl>` 中的S_IRUSR 宏，这个宏等于0400,这是一个8进制数据，低2位的0，对应group other 权限，如果单看user位置的权限，`r` 就是 4；
> `s` 对应 S_ISUID 宏，这个宏等于 0x04000;

更多的字母含义See: `man ls`


为了加深印象，让我们再看几个问题

#### 为什么我们可以在shell中执行`ls -lh` ?
你执行一下`ls -lh /bin` 就可以发现，ls 这个可执行文件的拥有者是 `root`，或者别的权限非常高的角色，但肯定不是你。可为啥我们可以执行它呢？  
运行一个可执行文件的条件是：  
   - 进程的有效ID是超管权限；
   - 进程的有效ID等于文件拥有者的ID；
  
如果你够细心，`sh` 属于 `root` 这种超管权限，而我们执行 ls 的时候，其实是通过进程 sh  fork 一个子进程，在子进程中exec ls命令。sh进程本身就是超管权限，其有效用户ID就是 root，那么它当然可以执行 ls 了。

#### 为什么我们编写一个c程序，用execv函数可以执行 `ps` 呢？
执行下 `ls -lh /bin` 就可以发现 `ps` 的拥有者是 `root`.这次我们是自己写了一个c程序，这就意味着该程序所在的进程，其有效用户ID就是我们自己，我们没有超管权限，可为什么我们能执行ps呢？  
仔细留意，会发现 `ps` 的权限user部分是 `rws`。`s` 意味着如果使用`execve`系统调用执行本文件时，可以将进程的有效ID重置为文件的拥有者ID，而 `execv` 底层调用的就是 `execve`，所以我们在自己的用户进程中可以执行 `ps`。

#### 文件拥有者的ID等于进程实际用户ID，还是有效用户ID？
文件是通过进程执行相应的API创建的，因此文件拥有者的ID等于创建该文件的进程的有效用户ID。  
进程实际用户ID，表示的是启动该进程的是谁；
进程的有效用户ID，表示的是在进程中，访问文件系统资源的权限是怎样的；

#### 文件组ID就是进程的有效组ID吗？
一般来讲是这样的，但还有一种情况是文件组ID是文件所在目录的组ID。


## API 快览
校验文件访问权限 - access
改变当前工作目录 - chdir
改变文件的权限   - chmod
改变文件拥有者   - chown
删除文件        - remove
重命名文件      - rename
遍历目录        - readdir
获取文件描述信息（权限，拥有者ID，组ID等）  - stat
设置文件权限屏蔽码 - umask
删除空目录        - rmdir
创建硬链接       - link
创建软连接       - symlink