// #include <unistd.h>
// pid_t setsid()
// 建立一个新的会话
//
// 如果调用本函数的进程已经是一个进程组组长，则返回-1
// 如果不是，调用进程会发生如下变化：
// 1. 成为会话首进程，也是新进程组的唯一进程
// 2. 成为新进程组组长；
// 3. 失去控制终端；
// 函数将返回本进程的PID

// 会话？
// 若干个进程组，集合在一起管理，就是一个会话。
// 以打开一个shell，执行 
//   proc1 | proc2 &
//   proc3 ｜ proc4
// 为例：
// 打开一个shell窗口时，会创建一个shell进程，这个进程建立一个和终端的连接，
// 这个终端就是 控制终端， shell进程就是控制进程。同时 shell进程还是会话
// 首进程，其本身就是一个后台进程组组长。
// 执行 proc1 | proc2 & 时，会形成一个新的后台进程组，proc1 和 proc2
// 进程就是组成员。
// 执行 proc3 ｜ proc4 时， 会形成一个新的前台进程组， proc3 和 proc4
// 进程就是组成员。
//
// 一个会话，只能有一个控制终端，一个前台进程组，1个或者多个后台进程组。
//
// 键入输入终端的中断键和退出键，会将终端信号发送给前台进程组所有进程。
// 终端接口发现到调制解调器或者网络的信号断开时，发送挂断信号到控制进程，也就是例子中的 shell进程。

#include <unistd.h>
#include <stdio.h>

int main() {

    pid_t pid = setsid();
    // 在这里 getsid(0) 和 getsid(pid) 等效
    printf("sid: %d\n", getsid(0));
    printf("pid: %d\n", getpid());
    printf("gid: %d\n", getgid());
}